---
title: "Milestone Report"
author: "Nille30"
date: "4/23/2020"
output: html_document
---

# Introduction
The goal of this project is just to display that you've gotten used to working with the data and that you are on track to create your prediction algorithm. Please submit a report on R Pubs (http://rpubs.com/) that explains your exploratory analysis and your goals for the eventual app and algorithm. This document should be concise and explain only the major features of the data you have identified and briefly summarize your plans for creating the prediction algorithm and Shiny app in a way that would be understandable to a non-data scientist manager. You should make use of tables and plots to illustrate important summaries of the data set. The motivation for this project is to: 1. Demonstrate that you've downloaded the data and have successfully loaded it in.2. Create a basic report of summary statistics about the data sets.3. Report any interesting findings that you amassed so far.4. Get feedback on your plans for creating a prediction algorithm and Shiny app.

```{r results='hide', message=FALSE, warning=FALSE, echo=FALSE}
library(RWekajars)
library(qdapDictionaries)
library(qdapRegex)
library(qdapTools)
library(RColorBrewer)
library(qdap)
library(NLP)
library(tm)
library(SnowballC)
library(slam)
library(RWeka)
library(rJava)
library(wordcloud)
library(stringr)
library(DT)
library(stringi)
library(googleVis)
```

# Data Processing
The provided data consists of three files in US English from different sources blogs, news and twitter.

### Loading The Dataset  
```{r, eval=FALSE, echo=FALSE}
blogs_data <- readLines("./Data/en_US/en_US.blogs.txt", encoding = "UTF-8", skipNul=TRUE)
news_data <- readLines("./Data/en_US/en_US.news.txt", encoding = "UTF-8", skipNul=TRUE)
twitter_data <- readLines("./Data/en_US/en_US.twitter.txt", encoding = "UTF-8", skipNul=TRUE)
```

### Aggreagating Sample Data
In order to ensure faster processing, a sample from the different sources are generated.
```{r, eval=FALSE}
twitter_sample <- twitter_data[sample(1:length(twitter_data),10000)]
news_sample <- news_data[sample(1:length(news_data),10000)]
blogs_sample <- blogs_data[sample(1:length(blogs_data),10000)]
combined_sample <- c(twitter_sample,news_sample,blogs_sample)
```

```{r, eval=FALSE, echo=FALSE}
## Save sample
writeLines(combined_sample, "./Data/combined_sample.txt")
```

```{r, eval=FALSE, echo=FALSE}
con_sample <- file("./Data/combined_sample.txt")
theSample <- readLines(con_sample)
close(con_sample)
```

# Summary Statistics
```{r, eval=FALSE, echo=FALSE}
## Checking the size and length of the files and calculate the word count
blogs_size <- file.info("./Data/en_US/en_US.blogs.txt")$size / 1024.0 / 1024.0
news_size <- file.info("./Data/en_US/en_US.news.txt")$size / 1024.0 / 1024.0
twitter_size <- file.info("./Data/en_US/en_US.twitter.txt")$size / 1024.0 / 1024.0
blogs_length <- length(blogs_data)
news_length <- length(news_data)
twitter_length <- length(twitter_data)
blogs_no_words <- sum(sapply(gregexpr("\\S+", blogs_data), length))
news_no_words <- sum(sapply(gregexpr("\\S+", news_data), length))
twitter_no_words <- sum(sapply(gregexpr("\\S+", twitter_data), length))
```

```{r, eval=FALSE, echo=FALSE}
summary_matrix <- data.frame(
        file_name = c("Blogs","News","Twitter"),
        file_size = c(round(blogs_size, digits = 2), 
                     round(news_size,digits = 2), 
                     round(twitter_size, digits = 2)),
        line_count = c(blogs_length, news_length, twitter_length),
        word_count = c(blogs_no_words, news_no_words, twitter_no_words))
```

```{r, eval=FALSE, echo=FALSE}
colnames(summary_matrix) <- c("File Name", "File Size (MB)", "No. of Lines", "No. of Words")
saveRDS(summary_matrix, file = "./data_summary.Rda")
```

```{r, eval=TRUE, echo=FALSE}
summary_df <- readRDS("./data_summary.Rda")
```
The table below provides an brief overview of the data characteristics.
```{r, echo=FALSE}
summary_df
```
```{r, eval=TRUE, echo=FALSE}
corp <- readRDS("./Data/corp_final.RDS")
```

```{r, echo=TRUE, message=FALSE, warning=FALSE}
tri_gram <- TermDocumentMatrix(corp)
word_cloud <- as.matrix(tri_gram)
sorted_tris <- sort(rowSums(word_cloud),decreasing=TRUE)
df_tris <- data.frame(word = names(sorted_tris),freq=sorted_tris)
wordcloud(df_tris$word,df_tris$freq, c(5,.3),50, random.order=FALSE, colors=brewer.pal(8, "Accent"))
```

# Cleaning the data and building a corpus
1. Transforming to lowercase
2. Removing punctuation
3. Removing numbers
4. Removing URLs
5. Removing stop words
6. Removing profanity
7. Removing white spaces generated by previous steps
```{r, eval=FALSE, echo=TRUE}
cleaned_sample <- Corpus(VectorSource(corp))
profanity_words <- read.table("./Data/profanity_words.txt", header = FALSE)
cleaned_sample <- tm_map(cleaned_sample, content_transformer(function(x) iconv(x, to="UTF-8", sub="byte")))
cleaned_sample <- tm_map(cleaned_sample, content_transformer(tolower))
cleaned_sample <- tm_map(cleaned_sample, content_transformer(removePunctuation))
cleaned_sample <- tm_map(cleaned_sample, content_transformer(removeNumbers))
removeURL <- function(x) gsub("http[[:alnum:]]*", "", x) 
cleaned_sample <- tm_map(cleaned_sample, content_transformer(removeURL))
cleaned_sample <- tm_map(cleaned_sample, stripWhitespace)
cleaned_sample <- tm_map(cleaned_sample, removeWords, stopwords("english"))
cleaned_sample <- tm_map(cleaned_sample, removeWords, profanity_words[,1])
cleaned_sample <- tm_map(cleaned_sample, stemDocument)
cleaned_sample <- tm_map(cleaned_sample, stripWhitespace)
```
```{r, eval=FALSE, echo=FALSE}
saveRDS(cleaned_sample, file = "./Data/corp_final.RDS")
corp <- readRDS("./Data/corp_final.RDS")
corp_df <-data.frame(text=unlist(sapply(corp,`[`, "content")), 
                           stringsAsFactors = FALSE)
```

## N-Gram Tokenizing
In Natural Language Processing (NLP) an *n*-gram is a contiguous sequence of n items from a given sequence of text or speech.
The following function is used to extract 1-grams, 2-grams and 2-grams from the cleaned text corpus.
```{r, eval=FALSE, echo=TRUE}
ngram_tokenizer <- function(corpus, ngram_count) {
        ngram_function <- ngram_tokenizer(corpus, 
                                Weka_control(min = ngram_count, max = ngram_count, 
                                delimiters = " \\r\\n\\t.,;:\"()?!"))
        ngram_function <- data.frame(table(ngram_function))
        ngram_function <- ngram_function[order(ngram_function$Freq, 
                                             decreasing = TRUE),][1:10,]
        colnames(ngram_function) <- c("String","Count")
        ngram_function
}
```
By the usage of the tokenizer function for the *n*-grams a distribution of the following top 10 words and word combinations can be inspected. Unigrams are single words, while bigrams are two word combinations and trigrams are three word combinations.

### Top Unigrams
```{r, results="asis"}
uni_gram <- readRDS("./Data/uni_gram.RDS")
uni_gramPlot <- gvisColumnChart(uni_gram, "String", "Count",                  
                            options=list(legend="none"))
print(uni_gramPlot, "chart")
```

### Top Bigrams
```{r, results="asis"}
bi_gram <- readRDS("./data/bi_gram.RDS")
bi_gramPlot <- gvisColumnChart(bi_gram, "String", "Count",                  
                            options=list(legend="none"))
print(bi_gramPlot, "chart")
```

### Top Trigrams
```{r, results="asis"}
tri_gram <- readRDS("./data/tri_gram.RDS")
tri_gramPlot <- gvisColumnChart(tri_gram, "String", "Count",                  
                            options=list(legend="none"))
print(tri_gramPlot, "chart")
```


